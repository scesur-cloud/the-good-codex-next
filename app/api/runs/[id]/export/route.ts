
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import AdmZip from 'adm-zip';

const SAFE_FILENAME_REGEX = /[^a-zA-Z0-9.\-_]/g;

export async function GET(req: NextRequest, props: { params: Promise<{ id: string }> }) {
    const params = await props.params;
    const runId = params.id;

    try {
        const run = await prisma.run.findUnique({
            where: { id: runId },
            include: {
                jobs: true,
                artifacts: true,
                evaluations: true
            }
        });

        if (!run) return NextResponse.json({ error: "Run not found" }, { status: 404 });

        const zip = new AdmZip();

        // Manifest for README
        const manifest: string[] = [];
        manifest.push(`Run Summary: run_summary.json`);

        // 1. Run Summary JSON
        zip.addFile("run_summary.json", Buffer.from(JSON.stringify(run, null, 2)));

        // 2. Artifacts Folder
        run.artifacts.forEach(art => {
            // Better filenames
            // If it has a clean extension, keep it. 
            // If it's PLAN or BRIEF, keep meaningful name.
            let safeName = art.fileName.replace(SAFE_FILENAME_REGEX, '_');
            const phaseFolder = art.phaseId ? art.phaseId : 'unknown_phase';

            // Dedupe logic not critical for zip (adm-zip overwrites or adds), but let's try to keep original names if possible
            // Just assume uniq filenames from system for now.
            zip.addFile(`artifacts/${phaseFolder}/${safeName}`, Buffer.from(art.contentText || ""));
            manifest.push(`Artifact (${phaseFolder}): artifacts/${phaseFolder}/${safeName} (${art.qaStatus || 'pending'})`);
        });

        // 3. Evaluations Folder
        zip.addFile("evaluations/all_evals.json", Buffer.from(JSON.stringify(run.evaluations, null, 2)));
        manifest.push(`Evaluations: evaluations/all_evals.json`);

        // 4. README_RUN.md
        const hasFinal = run.artifacts.some(a => a.isFinal);
        const readmeContent = `# Run Report: ${run.projectId}

## Metadata
- **Run ID**: ${run.id}
- **Date**: ${new Date(run.createdAt).toLocaleString()}
- **Phase**: ${run.phaseId}
- **Status**: ${run.status}
- **Final Winner**: ${hasFinal ? 'YES' : 'NO'}

## File Manifest
${manifest.map(m => `- ${m}`).join('\n')}

## Rubric Reference
(Used for QA)
- **Standard**: EDU_V1
- **Threshold**: 70/100
- **Logic**: Length > 100 chars = 80 points, else 40.

---
Generated by AntiGravity Agent Squad
`;
        zip.addFile("README_RUN.md", Buffer.from(readmeContent));

        const zipBuffer = zip.toBuffer();

        return new NextResponse(zipBuffer as any, {
            status: 200,
            headers: {
                'Content-Type': 'application/zip',
                'Content-Disposition': `attachment; filename="run_${run.projectId.replace(SAFE_FILENAME_REGEX, '')}_${run.id.slice(0, 6)}.zip"`
            }
        });

    } catch (e) {
        console.error(e);
        return NextResponse.json({ error: "Export Failed" }, { status: 500 });
    }
}
